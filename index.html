<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulation</title>
    <link rel="icon" type="image/x-icon" href="/logo.png">
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.95), rgba(50, 50, 50, 0.95));
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        #instructions {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.95), rgba(50, 50, 50, 0.95));
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            min-width: 220px;
        }
        .control-section {
            margin-bottom: 15px;
        }
        .control-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #ffd700;
        }
        .control-value {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
        }

        #lockMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #errorMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }
        .crosshair-line {
            position: absolute;
            background-color: #00ff00;
            opacity: 0.8;
        }
        .crosshair-horizontal {
            width: 20px;
            height: 2px;
            top: 9px;
            left: 0;
        }
        .crosshair-vertical {
            width: 2px;
            height: 20px;
            top: 0;
            left: 9px;
        }
        
        /* Planet Info Modal */
        #planetModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(40, 40, 80, 0.95));
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            font-family: 'Arial', sans-serif;
            max-width: 500px;
            min-width: 400px;
            display: none;
            z-index: 2000;
        }
        
        .modal-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.5);
            padding-bottom: 15px;
        }
        
        .planet-name {
            font-size: 28px;
            font-weight: bold;
            color: #ffd700;
            margin: 0;
        }
        
        .modal-content {
            display: grid;
            gap: 15px;
        }
        
        .fact-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .fact-label {
            font-weight: bold;
            color: #87ceeb;
            font-size: 16px;
        }
        
        .fact-value {
            color: #ffffff;
            font-size: 16px;
            text-align: right;
            max-width: 60%;
        }
        
        .fun-fact {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            font-style: italic;
            line-height: 1.4;
        }
        
        .close-instruction {
            text-align: center;
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-section">
            <div class="control-title">Orbital Speed</div>
            <div class="control-value"><span id="speedValue">0.00</span></div>
        </div>

    </div>
    <div id="instructions">
        <div class="control-title">Controls</div>
        <p><strong>WASD:</strong> Move horizontally</p>
        <p><strong>Q/E:</strong> Move up/down</p>
        <p><strong>Mouse:</strong> Look around (click to lock)</p>
        <p><strong>Shift:</strong> Sprint</p>
        <p><strong>Esc:</strong> Unlock mouse</p>
        <p><strong>←/→:</strong> Adjust orbit speed</p>
    </div>
    <div id="lockMessage">Click to lock mouse and explore<br>(Requires HTTPS or localhost)</div>
    <div id="errorMessage"></div>
    <div id="crosshair">
        <div class="crosshair-line crosshair-horizontal"></div>
        <div class="crosshair-line crosshair-vertical"></div>
    </div>
    
    <!-- Planet Info Modal -->
    <div id="planetModal">
        <div class="modal-header">
            <h2 class="planet-name" id="planetName">Planet Name</h2>
        </div>
        <div class="modal-content">
            <div class="fact-row">
                <span class="fact-label">Distance from Earth:</span>
                <span class="fact-value" id="planetDistance">Loading...</span>
            </div>
            <div class="fact-row">
                <span class="fact-label">Type:</span>
                <span class="fact-value" id="planetType">Loading...</span>
            </div>
            <div class="fact-row">
                <span class="fact-label">Temperature:</span>
                <span class="fact-value" id="planetTemperature">Loading...</span>
            </div>
            <div class="fact-row">
                <span class="fact-label">Gravity:</span>
                <span class="fact-value" id="planetGravity">Loading...</span>
            </div>
            <div class="fun-fact" id="planetFunFact">
                Loading interesting fact...
            </div>
        </div>
        <div class="close-instruction">
            Look away to close
        </div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

        const errorMessage = document.getElementById('errorMessage');
        const crosshair = document.getElementById('crosshair');

        // Planet facts data
        let planetFacts = {};
        
        // Load planet facts
        async function loadPlanetFacts() {
            try {
                const response = await fetch('./planet-facts.json');
                planetFacts = await response.json();
            } catch (error) {
                console.error('Failed to load planet facts:', error);
                // Fallback data if JSON fails to load
                planetFacts = {
                    "Mercury": {
                        "name": "Mercury",
                        "distanceFromEarth": "77.3 million km",
                        "temperature": "-173°C to 427°C",
                        "gravity": "0.38x Earth's gravity",
                        "funFact": "Mercury has no atmosphere and experiences extreme temperature swings!"
                    }
                    // Add more fallback data if needed
                };
            }
        }
        
        // Modal elements
        const planetModal = document.getElementById('planetModal');
        const planetNameEl = document.getElementById('planetName');
        const planetDistanceEl = document.getElementById('planetDistance');
        const planetTypeEl = document.getElementById('planetType');
        const planetTemperatureEl = document.getElementById('planetTemperature');
        const planetGravityEl = document.getElementById('planetGravity');
        const planetFunFactEl = document.getElementById('planetFunFact');
        
        let currentPlanetName = null;
        let modalVisible = false;
        let lookingAtPlanet = null;
        let lookStartTime = 0;
        
        // Show planet modal
        function showPlanetModal(planetName) {
            if (planetFacts[planetName] && !modalVisible) {
                const facts = planetFacts[planetName];
                planetNameEl.textContent = facts.name;
                planetDistanceEl.textContent = facts.distanceFromEarth;
                planetTypeEl.textContent = facts.type;
                planetTemperatureEl.textContent = facts.temperature;
                planetGravityEl.textContent = facts.gravity;
                planetFunFactEl.textContent = facts.funFact;
                
                planetModal.style.display = 'block';
                modalVisible = true;
                currentPlanetName = planetName;
            }
        }
        
        // Hide planet modal
        function hidePlanetModal() {
            planetModal.style.display = 'none';
            modalVisible = false;
            currentPlanetName = null;
            lookingAtPlanet = null;
            lookStartTime = 0;
        }

        function startSimulation() {
                // Scene setup
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({antialias:true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // FPS Controls
                let controls;
                const lockMessage = document.getElementById('lockMessage');
                const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                const isPointerLockSupported = 'pointerLockElement' in document;

                let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
                let isSprinting = false;
                const velocity = new THREE.Vector3();
                const direction = new THREE.Vector3();
                const speed = 50;

                // Fallback camera controls
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                if (isPointerLockSupported && isSecureContext) {
                    try {
                        controls = new PointerLockControls(camera, renderer.domElement);
                        lockMessage.style.display = 'block';

                        controls.addEventListener('lock', () => {
                            lockMessage.style.display = 'none';
                            controls.enabled = true;
                        });

                        controls.addEventListener('unlock', () => {
                            lockMessage.style.display = 'block';
                            controls.enabled = false;
                        });

                        document.addEventListener('click', () => {
                            if (!controls.isLocked) {
                                controls.lock();
                            }
                        });

                        controls.addEventListener('error', (event) => {
                            console.error('PointerLockControls error:', event);
                            lockMessage.textContent = 'Failed to lock mouse. Try HTTPS or localhost.';
                            lockMessage.style.display = 'block';
                            setupFallbackControls();
                        });
                    } catch (error) {
                        console.error('Failed to initialize PointerLockControls:', error);
                        lockMessage.textContent = 'Pointer lock failed. Using fallback controls.';
                        lockMessage.style.display = 'block';
                        setupFallbackControls();
                    }
                } else {
                    lockMessage.textContent = isPointerLockSupported
                        ? 'Pointer Lock requires HTTPS or localhost'
                        : 'Pointer Lock API not supported in this browser';
                    lockMessage.style.display = 'block';
                    setupFallbackControls();
                }

                function setupFallbackControls() {
                    document.addEventListener('mousedown', () => (isDragging = true));
                    document.addEventListener('mouseup', () => (isDragging = false));
                    document.addEventListener('mousemove', (event) => {
                        if (isDragging) {
                            const deltaMove = {
                                x: event.clientX - previousMousePosition.x,
                                y: event.clientY - previousMousePosition.y
                            };
                            camera.rotation.y -= deltaMove.x * 0.002;
                            camera.rotation.x -= deltaMove.y * 0.002;
                            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                        }
                        previousMousePosition = { x: event.clientX, y: event.clientY };
                    });
                }

                // Keyboard controls
                let speedMultiplier = 0;
                const speedValue = document.getElementById('speedValue');
                // ...existing code...
                
                // Raycaster setup
                const raycaster = new THREE.Raycaster();
                const center = new THREE.Vector2(0, 0); // Center of screen for raycasting
                let raycastDistance = 50; // Default raycast distance (fixed)

                document.addEventListener('keydown', (event) => {
                    switch (event.code) {
                        case 'KeyW': moveForward = true; break;   // W = forward
                        case 'KeyS': moveBackward = true; break; // S = backward
                        case 'KeyA': moveLeft = true; break;       // A = left
                        case 'KeyD': moveRight = true; break;      // D = right
                        case 'KeyQ': moveUp = true; break;         // Q = up
                        case 'KeyE': moveDown = true; break;       // E = down
                        case 'ShiftLeft': isSprinting = true; break;
                        case 'Escape': 
                            if (modalVisible) {
                                hidePlanetModal();
                            }
                            break;
                        case 'ArrowLeft':
                            speedMultiplier = Math.max(0, speedMultiplier - 0.2); // Step: 0.5
                            speedValue.textContent = speedMultiplier.toFixed(2); // Display two decimal places
                            break;
                        case 'ArrowRight':
                            speedMultiplier = Math.min(5, speedMultiplier + 0.2); // Changed max to 5, step: 0.5
                            speedValue.textContent = speedMultiplier.toFixed(2); // Display two decimal places
                            break;
                    }
                });

                document.addEventListener('keyup', (event) => {
                    switch (event.code) {
                        case 'KeyW': moveForward = false; break;
                        case 'KeyS': moveBackward = false; break;
                        case 'KeyA': moveLeft = false; break;
                        case 'KeyD': moveRight = false; break;
                        case 'KeyQ': moveUp = false; break;
                        case 'KeyE': moveDown = false; break;
                        case 'ShiftLeft': isSprinting = false; break;
                    }
                });

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 2); // Increased intensity
                scene.add(ambientLight);

                // Add a directional light to simulate sunlight
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
                directionalLight.position.set(0, 10, 0); // Position above the scene
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                // Make the sun emit light
                const sunLight = new THREE.PointLight(0xffff00, 2, 1000); // Bright yellow light
                sunLight.position.set(0, 0, 0); // Centered at the sun
                scene.add(sunLight);

                // Planets data with moons and rings
                const planets = [
                    { name: 'Mercury', radius: 0.5, distance: 10, speed: 0.02, color: 0xaaaaaa },
                    { name: 'Venus', radius: 0.8, distance: 15, speed: 0.015, color: 0xffcc00 },
                    { 
                        name: 'Earth', 
                        radius: 1, 
                        distance: 20, 
                        speed: 0.01, 
                        color: 0x0000ff,
                        moons: [
                            { name: 'Moon', radius: 0.27, distance: 3, speed: 0.03, color: 0xcccccc }
                        ]
                    },
                    { 
                        name: 'Mars', 
                        radius: 0.7, 
                        distance: 25, 
                        speed: 0.008, 
                        color: 0xff0000,
                        moons: [
                            { name: 'Phobos', radius: 0.1, distance: 2, speed: 0.04, color: 0x888888 },
                            { name: 'Deimos', radius: 0.08, distance: 2.5, speed: 0.03, color: 0x888888 }
                        ]
                    },
                    { 
                        name: 'Jupiter', 
                        radius: 2, 
                        distance: 35, 
                        speed: 0.005, 
                        color: 0xffa500,
                        moons: [
                            { name: 'Io', radius: 0.2, distance: 4, speed: 0.04, color: 0xffff00 },
                            { name: 'Europa', radius: 0.18, distance: 4.5, speed: 0.035, color: 0xffffff },
                            { name: 'Ganymede', radius: 0.25, distance: 5, speed: 0.03, color: 0xaaaaaa },
                            { name: 'Callisto', radius: 0.23, distance: 5.5, speed: 0.025, color: 0x888888 }
                        ]
                    },
                    { 
                        name: 'Saturn', 
                        radius: 1.8, 
                        distance: 45, 
                        speed: 0.004, 
                        color: 0xffff99,
                        rings: [
                            { innerRadius: 2.2, outerRadius: 3.5, color: 0xffff99 },
                            { innerRadius: 3.7, outerRadius: 4.5, color: 0xffaa66 }
                        ],
                        moons: [
                            { name: 'Titan', radius: 0.3, distance: 6, speed: 0.03, color: 0xffaa00 },
                            { name: 'Rhea', radius: 0.15, distance: 5, speed: 0.035, color: 0xcccccc }
                        ]
                    },
                    { 
                        name: 'Uranus', 
                        radius: 1.5, 
                        distance: 55, 
                        speed: 0.003, 
                        color: 0x00ffff,
                        rings: [
                            { innerRadius: 1.8, outerRadius: 2.5, color: 0x00ffff }
                        ],
                        moons: [
                            { name: 'Titania', radius: 0.2, distance: 4, speed: 0.03, color: 0xcccccc },
                            { name: 'Oberon', radius: 0.19, distance: 4.5, speed: 0.025, color: 0xaaaaaa }
                        ]
                    },
                    { 
                        name: 'Neptune', 
                        radius: 1.5, 
                        distance: 65, 
                        speed: 0.002, 
                        color: 0x000099,
                        rings: [
                            { innerRadius: 1.8, outerRadius: 2.2, color: 0x000099 }
                        ],
                        moons: [
                            { name: 'Triton', radius: 0.22, distance: 4, speed: -0.03, color: 0xcccccc }
                        ]
                    }
                ];

                // Create Sun - scaled to match planet scaling
                const sunGeometry = new THREE.SphereGeometry(40, 32, 32); // 8x larger than original
                const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                scene.add(sun);

                // Create Planets and Rings
                const planetMeshes = [];
                // Increase planet sizes by 8x and distances by 12x to prevent overlapping
                planets.forEach(planet => {
                    const scaledRadius = planet.radius * 8;
                    const scaledDistance = planet.distance * 12; // More spacing to prevent overlap

                    // Create orbital ring
                    const ringGeometry = new THREE.RingGeometry(scaledDistance - 0.1, scaledDistance + 0.1, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2; // Rotate to lie flat
                    scene.add(ring);

                    // Create planet
                    const geometry = new THREE.SphereGeometry(scaledRadius, 32, 32);
                    const material = new THREE.MeshPhongMaterial({ color: planet.color });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.x = scaledDistance;
                    scene.add(mesh);

                    // Create planet name label
                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: new THREE.CanvasTexture(createTextCanvas(planet.name, 'white', 'black')),
                        transparent: true
                    });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(10, 5, 1); // Adjust size of the label
                    sprite.position.set(0, scaledRadius + 5, 0); // Position above the planet
                    mesh.add(sprite);

                    // Create planet's rings if they exist
                    if (planet.rings) {
                        const planetRings = [];
                        planet.rings.forEach(ringData => {
                            const ringGeometry = new THREE.RingGeometry(
                                ringData.innerRadius * 8,  // Scale ring radius
                                ringData.outerRadius * 8,
                                64
                            );
                            const ringMaterial = new THREE.MeshBasicMaterial({
                                color: ringData.color,
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.8
                            });
                            const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                            ringMesh.rotation.x = Math.PI / 2;  // Lay flat
                            mesh.add(ringMesh);
                            planetRings.push(ringMesh);
                        });
                        mesh.rings = planetRings;
                    }

                    // Create moons if they exist
                    if (planet.moons) {
                        const moonMeshes = [];
                        planet.moons.forEach(moon => {
                            const scaledMoonRadius = moon.radius * 8;
                            const scaledMoonDistance = moon.distance * 8;

                            const moonGeometry = new THREE.SphereGeometry(scaledMoonRadius, 32, 32);
                            const moonMaterial = new THREE.MeshPhongMaterial({ color: moon.color });
                            const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
                            moonMesh.name = moon.name; // Set mesh name for easy identification
                            
                            // Create moon's orbit ring
                            const moonOrbitGeometry = new THREE.RingGeometry(
                                scaledMoonDistance - 0.1,
                                scaledMoonDistance + 0.1,
                                32
                            );
                            const moonOrbitMaterial = new THREE.MeshBasicMaterial({
                                color: 0xffffff,
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.3
                            });
                            const moonOrbit = new THREE.Mesh(moonOrbitGeometry, moonOrbitMaterial);
                            moonOrbit.rotation.x = Math.PI / 2;
                            mesh.add(moonOrbit);

                            // Create moon name label
                            const moonSpriteMaterial = new THREE.SpriteMaterial({
                                map: new THREE.CanvasTexture(createTextCanvas(moon.name, 'white', 'black')),
                                transparent: true
                            });
                            const moonSprite = new THREE.Sprite(moonSpriteMaterial);
                            moonSprite.scale.set(5, 2.5, 1);  // Half the size of planet labels
                            moonSprite.position.set(0, scaledMoonRadius + 2, 0);
                            moonMesh.add(moonSprite);

                            mesh.add(moonMesh);
                            moonMeshes.push({
                                mesh: moonMesh,
                                speed: moon.speed,
                                distance: scaledMoonDistance,
                                sprite: moonSprite
                            });
                        });
                        mesh.moons = moonMeshes;
                    }

                    planetMeshes.push({ 
                        mesh, 
                        ring, 
                        sprite, 
                        ...planet, 
                        scaledRadius, 
                        scaledDistance 
                    });
                });

                // Helper function to create text canvas
                function createTextCanvas(text, textColor, backgroundColor) {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 256;
                    canvas.height = 128;

                    // Background
                    context.fillStyle = backgroundColor;
                    context.fillRect(0, 0, canvas.width, canvas.height);

                    // Text
                    context.fillStyle = textColor;
                    context.font = '32px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(text, canvas.width / 2, canvas.height / 2);

                    return canvas;
                }

                // Collision detection function
                function checkCollisions(position, radius = 2) {
                    // Check collision with sun (scaled)
                    const sunDistance = position.distanceTo(sun.position);
                    if (sunDistance < 40 + radius) { // Updated sun radius
                        return true;
                    }
                    
                    // Check collision with planets using scaled radii
                    for (let planet of planetMeshes) {
                        const planetDistance = position.distanceTo(planet.mesh.position);
                        if (planetDistance < planet.scaledRadius + radius) {
                            return true;
                        }
                    }
                    return false;
                }

                // Camera initial position
                camera.position.set(0, 10, 100);

                // Store current angles for planets and moons
                const planetAngles = new Map();
                
                // Animation loop
                let prevTime = performance.now();
                function animate() {
                    requestAnimationFrame(animate);
                    const time = performance.now();
                    const delta = (time - prevTime) / 1000;
                    prevTime = time;

                    // Update planet positions and labels
                    planetMeshes.forEach(planet => {
                        // Initialize angle if not exists
                        if (!planetAngles.has(planet.mesh.uuid)) {
                            planetAngles.set(planet.mesh.uuid, {
                                planet: 0,
                                moons: new Map()
                            });
                        }
                        
                        // Get current angles and update them
                        const angles = planetAngles.get(planet.mesh.uuid);
                        angles.planet += planet.speed * speedMultiplier * delta * 60; // Multiply by 60 to maintain similar speed scale
                        
                        // Update planet position based on current angle
                        planet.mesh.position.x = planet.scaledDistance * Math.cos(angles.planet);
                        planet.mesh.position.z = planet.scaledDistance * Math.sin(angles.planet);

                        // Update label position
                        planet.sprite.position.set(0, planet.scaledRadius + 5, 0); // Keep label above the planet

                        // Animate moons if they exist
                        if (planet.mesh.moons) {
                            planet.mesh.moons.forEach(moon => {
                                // Initialize moon angle if not exists
                                if (!angles.moons.has(moon.mesh.uuid)) {
                                    angles.moons.set(moon.mesh.uuid, 0);
                                }
                                
                                // Update moon angle
                                const moonAngle = angles.moons.get(moon.mesh.uuid);
                                angles.moons.set(moon.mesh.uuid, moonAngle + moon.speed * speedMultiplier * delta * 60);
                                
                                // Update moon position
                                moon.mesh.position.x = moon.distance * Math.cos(moonAngle);
                                moon.mesh.position.z = moon.distance * Math.sin(moonAngle);
                            });
                        }
                    });

                    // Update raycaster
                    raycaster.setFromCamera(center, camera);
                    
                    // Gather all moon meshes for raycasting
                    const allMoonMeshes = [];
                    planetMeshes.forEach(planet => {
                        if (planet.mesh.moons) {
                            planet.mesh.moons.forEach(moon => {
                                allMoonMeshes.push(moon.mesh);
                            });
                        }
                    });
                    
                    // Create array of objects to test
                    const objectsToTest = [sun, ...planetMeshes.map(p => p.mesh), ...allMoonMeshes];
                    
                    // Get intersections
                    const intersects = raycaster.intersectObjects(objectsToTest, true);
                    
                    // Check if any intersection is within our raycast distance and handle modal
                    let nearPlanet = false;
                    let targetPlanetName = null;
                    
                    if (intersects.length > 0) {
                        const firstIntersect = intersects[0];
                        if (firstIntersect.distance <= raycastDistance) {
                            nearPlanet = true;
                            
                            // Find which planet, moon, or sun is being looked at
                            if (firstIntersect.object === sun) {
                                targetPlanetName = 'Sun';
                            } else {
                                // Check for planet
                                for (let planet of planetMeshes) {
                                    if (firstIntersect.object === planet.mesh) {
                                        targetPlanetName = planet.name;
                                        break;
                                    }
                                }
                                // Check for moon if not a planet
                                if (!targetPlanetName) {
                                    for (let planet of planetMeshes) {
                                        if (planet.mesh.moons) {
                                            for (let moon of planet.mesh.moons) {
                                                if (firstIntersect.object === moon.mesh) {
                                                    targetPlanetName = moon.mesh.name;
                                                    break;
                                                }
                                            }
                                        }
                                        if (targetPlanetName) break;
                                    }
                                }
                            }
                            
                            // Handle modal display timing
                            if (targetPlanetName) {
                                if (lookingAtPlanet === targetPlanetName) {
                                    // Still looking at the same planet, check if enough time has passed
                                    if (time - lookStartTime > 500 && !modalVisible) { // 0.5 seconds
                                        showPlanetModal(targetPlanetName);
                                    }
                                } else {
                                    // Started looking at a new planet
                                    lookingAtPlanet = targetPlanetName;
                                    lookStartTime = time;
                                    if (modalVisible && currentPlanetName !== targetPlanetName) {
                                        hidePlanetModal();
                                    }
                                }
                            }
                        }
                    }
                    
                    // Hide modal if not looking at any planet
                    if (!nearPlanet) {
                        if (modalVisible) {
                            hidePlanetModal();
                        }
                        lookingAtPlanet = null;
                        lookStartTime = 0;
                    }

                    // Show/hide crosshair based on raycast
                    crosshair.style.display = nearPlanet ? 'block' : 'none';

                    // Update camera movement with proper 3D camera-relative movement
                    // Adjust speed multiplier for sprinting
                    const currentSpeed = speed * delta * (isSprinting ? 128 : 64);
                    
                    // Get camera's world direction and right vector
                    const cameraDirection = new THREE.Vector3();
                    const cameraRight = new THREE.Vector3();
                    const cameraUp = new THREE.Vector3(0, 1, 0); // World up
                    
                    camera.getWorldDirection(cameraDirection);
                    cameraRight.crossVectors(cameraDirection, cameraUp).normalize();
                    
                    // Reset velocity for this frame
                    velocity.set(0, 0, 0);
                    
                    // Forward/backward movement (W/S) - move in camera direction
                    if (moveForward) {
                        velocity.add(cameraDirection.clone().multiplyScalar(currentSpeed));
                    }
                    if (moveBackward) {
                        velocity.add(cameraDirection.clone().multiplyScalar(-currentSpeed));
                    }
                    
                    // Left/right movement (A/D) - move perpendicular to camera direction
                    if (moveLeft) {
                        velocity.add(cameraRight.clone().multiplyScalar(-currentSpeed));
                    }
                    if (moveRight) {
                        velocity.add(cameraRight.clone().multiplyScalar(currentSpeed));
                    }
                    
                    // Up/down movement (Q/E) - move in world Y direction
                    if (moveUp) {
                        velocity.y += currentSpeed;
                    }
                    if (moveDown) {
                        velocity.y -= currentSpeed;
                    }

                    if (isPointerLockSupported && isSecureContext && controls && controls.isLocked) {
                        // Test new position for collision
                        const testPosition = controls.getObject().position.clone();
                        testPosition.add(velocity.clone().multiplyScalar(delta));
                        
                        if (!checkCollisions(testPosition)) {
                            controls.getObject().position.add(velocity.clone().multiplyScalar(delta));
                        }
                    } else {
                        // Test new position for collision (fallback controls)
                        const testPosition = camera.position.clone();
                        testPosition.add(velocity.clone().multiplyScalar(delta));
                        
                        if (!checkCollisions(testPosition)) {
                            camera.position.add(velocity.clone().multiplyScalar(delta));
                        }
                    }

                    renderer.render(scene, camera);
                }
                animate();

                // Handle window resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
        // Load planet facts and start simulation
        loadPlanetFacts().then(() => {
            startSimulation();
        });
    </script>
    <!-- Simple Analytics - 100% privacy-first analytics -->
<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>